<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Quick Sort - algorism.</title>

    <link rel="shortcut icon" href="favicon.png" type="image" />
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <header class="header">
      <a href="#" class="logo-text">algorism. </a>

      <nav>
        <button class="bubble-btn">
          Bubble Sort
        </button>
        <button class="selection-btn">
          Selection Sort
        </button>
        <button class="insertion-btn">
          Insertion Sort
        </button>
        <button class="merge-btn">
          Merge Sort
        </button>
      </nav>
    </header>
    <div class="main-container">
      <h1 class="heading">Quick Sort</h1>

      <div class="controls">
        <button class="generate-array-btn">Generate Array</button>
        <div class="array-container" id="array-container"></div>

        <div class="speed-container">
            <label for="speed">Speed: (max to min)</label>
            <input type="range" min="0" max="300" value="0" name="speed" id="speed" />
          </div>

          <button class="quick-sort-btn">Sort</button>
      </div>

      <div class="main-area">
        <div class="blocks-container">
          <div class="blocks"></div>
        </div>

        <div class="algo-container">
          <div class="card">
            <div class="header-card">
              <div class="top">
                <div class="circle">
                  <span class="red circle2"></span>
                </div>
                <div class="circle">
                  <span class="yellow circle2"></span>
                </div>
                <div class="circle">
                  <span class="green circle2"></span>
                </div>
                <div class="title">
                  <p id="title2">Quick Sort</p>
                </div>
              </div>
            </div>
            
            <div class="code-result-container">
                <div class="code-container">

                    <p class="algo">
                      void quickSort(int[] array, int low, int high) {</br>
                        &emsp;if (low < high) {</br>
                          &emsp;&emsp;<span class="comment">// Partition the array and get the pivot index</span></br>
                          &emsp;&emsp;int pivotIndex = partition(array, low, high);</br>
                
                          &emsp;&emsp;<span class="comment">// Recursively sort elements before and after partition</span></br>
                          &emsp;&emsp;quickSort(array, low, pivotIndex - 1);</br>
                          &emsp;&emsp;quickSort(array, pivotIndex + 1, high);</br>
                          &emsp;}</br>
                    }</br></br>
                
                    <span class="comment">// Function to partition the array</span></br>
                    int partition(int[] array, int low, int high) {</br>
                      &emsp;int pivot = array[high]; <span class="comment">// Choose the last element as pivot</span></br>
                      &emsp;int i = low - 1; <span class="comment">// Index of smaller element</span></br>
                
                      &emsp;for (int j = low; j < high; j++) {</br>
                        &emsp;&emsp;<span class="comment">// If the current element is smaller than or equal to pivot</span></br>
                        &emsp;&emsp;if (array[j] <= pivot) {</br>
                          &emsp;&emsp;&emsp;i++;</br>
                          &emsp;&emsp;&emsp;// Swap array[i] and array[j]</br>
                          &emsp;&emsp;&emsp;int temp = array[i];</br>
                          &emsp;&emsp;&emsp;array[i] = array[j];</br>
                          &emsp;&emsp;&emsp;array[j] = temp;</br>
                          &emsp;&emsp;}</br>
                          &emsp;}</br>
                
                          &emsp;<span class="comment">// Swap the pivot element with the element at i+1</span></br>
                          &emsp;int temp = array[i + 1];</br>
                          &emsp;array[i + 1] = array[high];</br>
                          &emsp;array[high] = temp;</br>
                
                          &emsp;return i + 1; <span class="comment">// Return the partition index</span></br>
                    }</br>
                    </p>
                </div>

                
                    <div class="result-container">
                        <p class="output-text">
Result will be displayed here.
                        </p>
                    </div>
                </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="info">
      <h1>More about Quick Sort:</h1>
<p>
  Quick Sort is a highly efficient sorting algorithm that uses the divide-and-conquer approach. It works by selecting a pivot element, partitioning the array around the pivot, and then recursively sorting the subarrays on either side of the pivot.
</p>

<ul>
  <li>Key Features
    <ol>
      <li>Divide and Conquer: Quick Sort divides the array into smaller subarrays based on the pivot element.</li>
      <li>In-Place Sorting: Quick Sort sorts the array without requiring additional memory, making it space-efficient.</li>
      <li>Highly Efficient: It performs well in practice for large datasets, especially with a good pivot selection.</li>
      <li>Comparison-Based Algorithm: It compares elements to partition and sort the array.</li>
      <li>Not Stable: Quick Sort does not guarantee stability since equal elements may not maintain their relative order.</li>
    </ol>
  </li>
  <li>Time Complexity
    <ul>
      <li>Best Case: O(n log n) - Occurs when the pivot divides the array into roughly equal halves.</li>
      <li>Average Case: O(n log n) - Common for randomized pivot selection.</li>
      <li>Worst Case: O(n^2) - Happens when the pivot divides the array into highly unbalanced partitions (e.g., sorted or reverse-sorted input).</li>
    </ul>
  </li>
  <li>Space Complexity: O(log n) for the recursive stack in the best case; O(n) in the worst case due to recursion depth.</li>
  <li>Algorithm Steps
    <ol>
      <li>Choose a Pivot: Select a pivot element from the array. Common choices include the first, last, middle, or a random element.</li>
      <li>Partition the Array: Rearrange elements so that all elements smaller than the pivot are on the left, and all elements larger are on the right.</li>
      <li>Place the Pivot in Its Correct Position: After partitioning, the pivot is in its sorted position.</li>
      <li>Recursively Sort Subarrays: Apply the same steps to the left and right subarrays around the pivot.</li>
      <li>Stop When Subarrays Have One Element: The algorithm terminates when all subarrays have been sorted and merged into a single array.</li>
    </ol>
  </li>
</ul> 
    </div>


    <hr>
    <footer>
        <p class="footer">Made with ❤️ by Yuvraj Patil</p>
    </footer>

    <script src="main.js"></script>
  </body>
</html>
